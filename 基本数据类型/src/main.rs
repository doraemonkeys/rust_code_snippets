fn main() {
    // åœ¨å…¶å®ƒè¯­è¨€ä¸­ï¼Œæˆ‘ä»¬ç”¨ `var a = "hello world"` çš„æ–¹å¼ç»™ `a` èµ‹å€¼ï¼Œ
    // ä¹Ÿå°±æ˜¯æŠŠç­‰å¼å³è¾¹çš„ `"hello world"` å­—ç¬¦ä¸²èµ‹å€¼ç»™å˜é‡ `a` ï¼Œ
    // è€Œåœ¨ Rust ä¸­ï¼Œæˆ‘ä»¬è¿™æ ·å†™ï¼š `let a = "hello world"` ï¼ŒåŒæ—¶ç»™è¿™ä¸ªè¿‡ç¨‹èµ·äº†å¦ä¸€ä¸ªåå­—ï¼šå˜é‡ç»‘å®šã€‚

    // ä¸ºä½•ä¸ç”¨èµ‹å€¼è€Œç”¨ç»‘å®šå‘¢ï¼ˆå…¶å®ä½ ä¹Ÿå¯ä»¥ç§°ä¹‹ä¸ºèµ‹å€¼ï¼Œä½†æ˜¯ç»‘å®šçš„å«ä¹‰æ›´æ¸…æ™°å‡†ç¡®ï¼‰ï¼Ÿ
    // è¿™é‡Œå°±æ¶‰åŠ Rust æœ€æ ¸å¿ƒçš„åŸåˆ™â€”â€”æ‰€æœ‰æƒã€‚

    // å˜é‡
    study_variable_binding();
    // Rust çš„æ•°å€¼ä¸Šå¯ä»¥ä½¿ç”¨æ–¹æ³•
    // åŸºæœ¬æ•°æ®ç±»å‹
    study_basic_data_types();
    // æœ‰ç†æ•°å’Œå¤æ•°
    study_rational_and_complex();
    // å­—ç¬¦ã€å¸ƒå°”ã€å•å…ƒç±»å‹
    study_char_bool_unit();
    // ç±»å‹è½¬æ¢
    study_type_conversion();
    // å…¨å±€å˜é‡
    study_global_variable();
}

fn study_global_variable() {
    println!("-----------------å…¨å±€å˜é‡-----------------");
    // å…¨å±€å˜é‡çš„ç”Ÿå‘½å‘¨æœŸè‚¯å®šæ˜¯`'static`ï¼Œä½†æ˜¯ä¸ä»£è¡¨å®ƒéœ€è¦ç”¨`static`æ¥å£°æ˜ï¼Œ
    // ä¾‹å¦‚å¸¸é‡ã€å­—ç¬¦ä¸²å­—é¢å€¼ç­‰æ— éœ€ä½¿ç”¨`static`è¿›è¡Œå£°æ˜ï¼ŒåŸå› æ˜¯å®ƒä»¬å·²ç»è¢«æ‰“åŒ…åˆ°äºŒè¿›åˆ¶å¯æ‰§è¡Œæ–‡ä»¶ä¸­ã€‚

    // é™æ€å¸¸é‡
    println!("-----------------é™æ€å¸¸é‡-----------------");
    // å¸¸é‡å¯ä»¥åœ¨ä»»æ„ä½œç”¨åŸŸè¿›è¡Œå®šä¹‰ï¼Œå…¶ç”Ÿå‘½å‘¨æœŸè´¯ç©¿æ•´ä¸ªç¨‹åºçš„ç”Ÿå‘½å‘¨æœŸã€‚ç¼–è¯‘æ—¶ç¼–è¯‘å™¨ä¼šå°½å¯èƒ½å°†å…¶å†…è”åˆ°ä»£ç ä¸­ï¼Œ
    // æ‰€ä»¥åœ¨ä¸åŒåœ°æ–¹å¯¹åŒä¸€å¸¸é‡çš„å¼•ç”¨å¹¶ä¸èƒ½ä¿è¯å¼•ç”¨åˆ°ç›¸åŒçš„å†…å­˜åœ°å€ã€‚
    const MAX_ID: usize = usize::MAX / 2; // é€‚åˆç”¨ä½œé™æ€é…ç½®
    println!("ç”¨æˆ·IDå…è®¸çš„æœ€å¤§å€¼æ˜¯{}", MAX_ID);

    // é™æ€å˜é‡
    println!("-----------------é™æ€å˜é‡-----------------");
    static mut REQUEST_RECV: usize = 0;
    // é™æ€å˜é‡ä¸ä¼šè¢«å†…è”ï¼Œåœ¨æ•´ä¸ªç¨‹åºä¸­ï¼Œé™æ€å˜é‡åªæœ‰ä¸€ä¸ªå®ä¾‹ï¼Œæ‰€æœ‰çš„å¼•ç”¨éƒ½ä¼šæŒ‡å‘åŒä¸€ä¸ªåœ°å€ï¼›
    // å­˜å‚¨åœ¨é™æ€å˜é‡ä¸­çš„å€¼å¿…é¡»è¦å®ç° Sync trait

    // const å’Œ static çš„åŒºåˆ«
    fn foo() -> (i32, i32) {
        static X1: AtomicUsize = AtomicUsize::new(1);
        const X2: AtomicUsize = AtomicUsize::new(99);
        (
            X1.fetch_add(1, Ordering::SeqCst) as i32,
            X2.fetch_add(1, Ordering::SeqCst) as i32,
        )
    }
    println!("first call foo: {:?}", foo()); // (1, 99)
    println!("second call foo: {:?}", foo()); // (2, 99)

    // åŸå­ç±»å‹
    println!("-----------------åŸå­ç±»å‹-----------------");
    // æƒ³è¦å…¨å±€è®¡æ•°å™¨ã€çŠ¶æ€æ§åˆ¶ç­‰åŠŸèƒ½ï¼Œåˆæƒ³è¦çº¿ç¨‹å®‰å…¨çš„å®ç°ï¼ŒåŸå­ç±»å‹æ˜¯éå¸¸å¥½çš„åŠæ³•ã€‚
    use std::sync::atomic::{AtomicUsize, Ordering};
    static REQUEST_RECV_ATOMIC: AtomicUsize = AtomicUsize::new(0);

    // lazy_staticæ˜¯ç¤¾åŒºæä¾›çš„éå¸¸å¼ºå¤§çš„å®ï¼Œç”¨äºæ‡’åˆå§‹åŒ–é™æ€å˜é‡ï¼Œä¹‹å‰çš„é™æ€å˜é‡éƒ½æ˜¯åœ¨ç¼–è¯‘æœŸåˆå§‹åŒ–çš„ï¼Œ
    // å› æ­¤æ— æ³•ä½¿ç”¨å‡½æ•°è°ƒç”¨è¿›è¡Œèµ‹å€¼ï¼Œè€Œ lazy_static å…è®¸æˆ‘ä»¬åœ¨è¿è¡ŒæœŸåˆå§‹åŒ–é™æ€å˜é‡ï¼
    println!("-----------------lazy_static-----------------");
    use lazy_static::lazy_static;
    use std::sync::Mutex;

    // ä¸ºä»€ä¹ˆéœ€è¦è¿è¡Œåˆå§‹åŒ–ï¼Ÿä»¥ä¸‹çš„é™æ€åˆå§‹åŒ–æœ‰ä¸€ä¸ªè‡´å‘½çš„é—®é¢˜ï¼š
    // æ— æ³•ç”¨å‡½æ•°è¿›è¡Œé™æ€åˆå§‹åŒ–ï¼Œä¾‹å¦‚ä½ å¦‚æœæƒ³å£°æ˜ä¸€ä¸ªå…¨å±€çš„Mutexé”
    // static NAMES1: Mutex<String> = Mutex::new(String::from("Sunface, Jack, Allen"));

    lazy_static! {
        // lazy_static å®ï¼ŒåŒ¹é…çš„æ˜¯ static ref ï¼Œæ‰€ä»¥å®šä¹‰çš„é™æ€å˜é‡éƒ½æ˜¯ä¸å¯å˜å¼•ç”¨ã€‚
        // lazy_static å®šä¹‰åç›´åˆ°ä½¿ç”¨è¯¥å˜é‡ï¼Œæ‰è¿›è¡Œåˆå§‹åŒ–ï¼Œéå¸¸ lazy static ã€‚
        static ref NAMES: Mutex<String> = Mutex::new(String::from("Sunface, Jack, Allen"));
    }
    // OnceCell
    println!("-----------------OnceCell-----------------");
    #[allow(unused_imports)]
    use std::cell::OnceCell;
    // OnceCell æ˜¯ç”¨äºå•çº¿ç¨‹ç¯å¢ƒä¸‹çš„æ‡’åŠ è½½æ•°æ®ç»“æ„ã€‚
    // å®ƒå¯ä»¥ç”¨æ¥å­˜å‚¨æŸä¸ªå€¼ï¼Œå¹¶åœ¨éœ€è¦æ—¶è¿›è¡Œåˆå§‹åŒ–ï¼Œä½†æ˜¯åªèƒ½åœ¨å•çº¿ç¨‹ç¯å¢ƒä¸‹ä½¿ç”¨ã€‚

    // OnceLock
    println!("-----------------OnceLock-----------------");
    // OnceCell å’Œå®ƒçš„çº¿ç¨‹å®‰å…¨å¯¹åº”ç±»å‹ OnceLockä¸¤ä¸ªæ–°çš„ç±»å‹åœ¨1.70ç¨³å®šä¸‹æ¥ï¼Œç”¨äºå…±äº«æ•°æ®çš„ä¸€æ¬¡æ€§åˆå§‹åŒ–ã€‚

    use std::sync::OnceLock;
    static DATA: OnceLock<&str> = OnceLock::new();

    fn init_example() {
        let winner = std::thread::scope(|s| {
            s.spawn(|| DATA.set("thread"));

            std::thread::yield_now(); // give them a chance...

            // Many threads may call get_or_init concurrently with different
            // initializing functions, but it is guaranteed that only one function will be executed.
            DATA.get_or_init(|| "main")
        });

        println!("{winner} wins!");
    }

    init_example();

    // Box::leak
    println!("-----------------Box::leak-----------------");
    // æˆ‘ä»¬æåˆ°äº†Box::leakå¯ä»¥ç”¨äºå…¨å±€å˜é‡ï¼Œä¾‹å¦‚ç”¨ä½œè¿è¡ŒæœŸåˆå§‹åŒ–çš„å…¨å±€åŠ¨æ€é…ç½®ï¼Œ
    // å…ˆæ¥çœ‹çœ‹å¦‚æœä¸ä½¿ç”¨lazy_staticä¹Ÿä¸ä½¿ç”¨Box::leakï¼Œä¼šå‘ç”Ÿä»€ä¹ˆï¼š
    #[derive(Debug)]
    struct Config {
        _a: String,
        _b: String,
    }
    static mut CONFIG: Option<&mut Config> = None;
    fn test_no_lazy() {
        let c = Box::new(Config {
            _a: "A".to_string(),
            _b: "B".to_string(),
        });

        unsafe {
            // æŠ¥é”™ï¼ŒRust çš„å€Ÿç”¨å’Œç”Ÿå‘½å‘¨æœŸè§„åˆ™é™åˆ¶äº†æˆ‘ä»¬åšåˆ°è¿™ä¸€ç‚¹ï¼Œ
            // å› ä¸ºè¯•å›¾å°†ä¸€ä¸ªå±€éƒ¨ç”Ÿå‘½å‘¨æœŸçš„å˜é‡èµ‹å€¼ç»™å…¨å±€ç”Ÿå‘½å‘¨æœŸçš„CONFIGï¼Œè¿™æ˜æ˜¾æ˜¯ä¸å®‰å…¨çš„ã€‚
            // CONFIG = Some(&mut Config {
            //     a: "A".to_string(),
            //     b: "B".to_string(),
            // });

            // å¥½åœ¨`Rust`ä¸ºæˆ‘ä»¬æä¾›äº†`Box::leak`æ–¹æ³•ï¼Œå®ƒå¯ä»¥å°†ä¸€ä¸ªå˜é‡ä»å†…å­˜ä¸­æ³„æ¼(å¬ä¸Šå»æ€ªæ€ªçš„ï¼Œç«Ÿç„¶åšä¸»åŠ¨å†…å­˜æ³„æ¼)ï¼Œ
            // ç„¶åå°†å…¶å˜ä¸º`'static`ç”Ÿå‘½å‘¨æœŸï¼Œæœ€ç»ˆè¯¥å˜é‡å°†å’Œç¨‹åºæ´»å¾—ä¸€æ ·ä¹…ï¼Œå› æ­¤å¯ä»¥èµ‹å€¼ç»™å…¨å±€é™æ€å˜é‡`CONFIG`ã€‚
            // å°†`c`ä»å†…å­˜ä¸­æ³„æ¼ï¼Œå˜æˆ`'static`ç”Ÿå‘½å‘¨æœŸ
            CONFIG = Some(Box::leak(c));
            println!("{:?}", CONFIG);
        }
    }
    test_no_lazy();
    unsafe {
        REQUEST_RECV += 1;
        // Rust è¦æ±‚å¿…é¡»ä½¿ç”¨unsafeè¯­å¥å—æ‰èƒ½è®¿é—®å’Œä¿®æ”¹staticå˜é‡ï¼Œå› ä¸ºè¿™ç§ä½¿ç”¨æ–¹å¼å¾€å¾€å¹¶ä¸å®‰å…¨ï¼Œ
        // å…¶å®ç¼–è¯‘å™¨æ˜¯å¯¹çš„ï¼Œå½“åœ¨å¤šçº¿ç¨‹ä¸­åŒæ—¶å»ä¿®æ”¹æ—¶ï¼Œä¼šä¸å¯é¿å…çš„é‡åˆ°è„æ•°æ®
        assert_eq!(REQUEST_RECV, 1);
    }

    for _ in 0..100 {
        REQUEST_RECV_ATOMIC.fetch_add(1, Ordering::Relaxed);
    }
    println!("å½“å‰ç”¨æˆ·è¯·æ±‚æ•°{:?}", REQUEST_RECV_ATOMIC);

    //lazy_staticç›´åˆ°è¿è¡Œåˆ°mainä¸­çš„ç¬¬ä¸€è¡Œä»£ç æ—¶ï¼Œæ‰è¿›è¡Œåˆå§‹åŒ–ï¼Œéå¸¸lazy static
    let mut v = NAMES.lock().unwrap();
    v.push_str(", Tom");
    println!("{}", v);

    // ä»å‡½æ•°ä¸­è¿”å›å…¨å±€å˜é‡
    println!("-----------------ä»å‡½æ•°ä¸­è¿”å›å…¨å±€å˜é‡-----------------");
    fn init() -> Option<&'static mut Config> {
        let c = Box::new(Config {
            _a: "A".to_string(),
            _b: "B".to_string(),
        });

        Some(Box::leak(c)) // å°†`c`ä»å†…å­˜ä¸­æ³„æ¼ï¼Œå˜æˆ`'static`ç”Ÿå‘½å‘¨æœŸ
    }
    unsafe {
        CONFIG = init();
        println!("{:?}", CONFIG)
    }

    // æ ‡å‡†åº“ä¸­çš„ OnceCell
    println!("-----------------OnceCell-----------------");
    // åœ¨ Rust æ ‡å‡†åº“ä¸­æä¾› lazy::OnceCell å’Œ lazy::SyncOnceCell ä¸¤ç§ Cellï¼Œ
    // å‰è€…ç”¨äºå•çº¿ç¨‹ï¼Œåè€…ç”¨äºå¤šçº¿ç¨‹ï¼Œå®ƒä»¬ç”¨æ¥å­˜å‚¨å †ä¸Šçš„ä¿¡æ¯ï¼Œå¹¶ä¸”å…·æœ‰æœ€å¤šåªèƒ½èµ‹å€¼ä¸€æ¬¡çš„ç‰¹æ€§ã€‚
    // å¦‚å®ç°ä¸€ä¸ªå¤šçº¿ç¨‹çš„æ—¥å¿—ç»„ä»¶ Loggerï¼š
    example_logger();
}

fn example_logger() {
    println!("-----------------example_logger-----------------");
    // #![feature(once_cell)]
    // ç›®å‰ `OnceCell` å’Œ `SyncOnceCell` API æš‚æœªç¨³å®šï¼Œéœ€å¯ç”¨ç‰¹æ€§ `#![feature(once_cell)]`ã€‚
}

fn study_type_conversion() {
    // Rust ä¸æä¾›åŸç”Ÿç±»å‹ä¹‹é—´çš„éšå¼ç±»å‹è½¬æ¢ï¼ˆcoercionï¼‰ï¼Œä½†å¯ä»¥ä½¿ç”¨ as å…³é”®å­—è¿›è¡Œæ˜¾ å¼ç±»å‹è½¬æ¢ï¼ˆcastingï¼‰ã€‚
    println!("-----------------ç±»å‹è½¬æ¢-----------------");
    let decimal = 65.4321_f32;

    // é”™è¯¯ï¼ä¸æä¾›éšå¼è½¬æ¢
    //let integer: u8 = decimal;

    // å¯ä»¥æ˜¾å¼è½¬æ¢
    let integer = decimal as u8;
    let character = integer as char;

    println!("Casting: {} -> {} -> {}", decimal, integer, character);

    // å½“æŠŠä»»ä½•ç±»å‹è½¬æ¢ä¸ºæ— ç¬¦å·ç±»å‹ T æ—¶ï¼Œä¼šä¸æ–­åŠ ä¸Šæˆ–å‡å» (std::T::MAX + 1)
    // ç›´åˆ°å€¼ä½äºæ–°ç±»å‹ T çš„èŒƒå›´å†…ã€‚

    // 1000 å·²ç»åœ¨ u16 çš„èŒƒå›´å†…
    println!("1000 as a u16 is: {}", 1000 as u16);

    // int8 çš„èŒƒå›´æ˜¯ -128..=127
    let num = 128;
    println!("{} as a i8 is : {}", num, num as i8); // -128

    // MaxInt8
    let num = -1i8;
    let max_int8 = ((num as u8) >> 1) as i8;
    println!("max_int8 = {}", max_int8);
    let max_int8_2 = std::i8::MAX;
    assert_eq!(max_int8, max_int8_2);

    // try_from å’Œ try_into
    // ä» Rust 1.34 å¼€å§‹ï¼Œæ ‡å‡†åº“æä¾›äº† `TryFrom` å’Œ `TryInto` ä¸¤ä¸ª traitï¼Œ
    // å®ƒä»¬å¯ä»¥åœ¨è½¬æ¢å¤±è´¥æ—¶è¿”å›é”™è¯¯ï¼Œè€Œä¸æ˜¯ panicã€‚
    // TryFrom å’Œ TryInto trait ç”¨äºæ˜“å‡ºé”™çš„è½¬æ¢ï¼Œä¹Ÿæ­£å› å¦‚æ­¤ï¼Œå…¶è¿”å›å€¼æ˜¯ Result å‹ã€‚
    println!("-----------------try_from å’Œ try_into-----------------");
    let num = 128;
    let num: Result<i8, _> = num.try_into();
    if let Ok(num) = num {
        // å¦‚æœnumæ˜¯Okç±»å‹ï¼Œå°±å°†numèµ‹å€¼ç»™num
        println!("num = {}", num);
    } else {
        // è¿™é‡Œ128è¶…å‡ºäº†i8çš„èŒƒå›´ï¼Œæ‰€ä»¥ä¼šæ‰“å°å‡ºé”™è¯¯ä¿¡æ¯
        println!("num = {:?}", num);
    }
    // try_from
    let num = 128;
    let num: Result<i8, _> = i8::try_from(num);
    if let Ok(num) = num {
        // å¦‚æœnumæ˜¯Okç±»å‹ï¼Œå°±å°†numèµ‹å€¼ç»™num
        println!("num = {}", num);
    } else {
        // è¿™é‡Œ128è¶…å‡ºäº†i8çš„èŒƒå›´ï¼Œæ‰€ä»¥ä¼šæ‰“å°å‡ºé”™è¯¯ä¿¡æ¯
        println!("num = {:?}", num);
    }
    // è§£æå­—ç¬¦ä¸²
    println!("-----------------è§£æå­—ç¬¦ä¸²-----------------");
    let parsed: i32 = "5".parse().unwrap();
    let turbo_parsed = "10".parse::<i32>().unwrap();

    let sum = parsed + turbo_parsed;
    println! {"Sum: {:?}", sum};
    // å¦‚æœè¦è½¬æ¢åˆ°ç”¨æˆ·å®šä¹‰ç±»å‹ï¼Œåªè¦æ‰‹åŠ¨å®ç° FromStr trait å°±è¡Œã€‚
    // ä¾‹å¦‚ï¼Œæˆ‘ä»¬å¯ä»¥å°†å­—ç¬¦ä¸²è½¬æ¢ä¸º Point ç»“æ„ä½“ï¼š
    println!("-----------------è§£æå­—ç¬¦ä¸²åˆ°ç”¨æˆ·å®šä¹‰ç±»å‹-----------------");
    let point = "1,2".parse::<Point>();
    let point = match point {
        Ok(point) => point,
        Err(e) => {
            println!("Error: {:?}", e);
            Point { _x: 0, _y: 0 }
        }
    };
    println!("point = {:?}", point);

    // å†…å­˜åœ°å€è½¬æ¢ä¸ºæŒ‡é’ˆ
    println!("-----------------å†…å­˜åœ°å€è½¬æ¢ä¸ºæŒ‡é’ˆ-----------------");
    let mut values: [i32; 2] = [1, 2];
    let p1: *mut i32 = values.as_mut_ptr();
    let first_address = p1 as usize; // å°†p1å†…å­˜åœ°å€è½¬æ¢ä¸ºä¸€ä¸ªæ•´æ•°
    let second_address = first_address + 4; // 4 == std::mem::size_of::<i32>()ï¼Œi32ç±»å‹å ç”¨4ä¸ªå­—èŠ‚ï¼Œå› æ­¤å°†å†…å­˜åœ°å€ + 4
    let p2 = second_address as *mut i32; // è®¿é—®è¯¥åœ°å€æŒ‡å‘çš„ä¸‹ä¸€ä¸ªæ•´æ•°p2
    unsafe {
        *p2 += 1;
    }
    println!("values = {:?}", values); // [1, 3]
}

#[derive(Debug)]
struct Point {
    _x: i32,
    _y: i32,
}
#[derive(Debug, PartialEq, Eq)]
struct ParsePointError;

impl std::str::FromStr for Point {
    type Err = ParsePointError;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s.find(',') {
            None => Err(ParsePointError),
            Some(index) => {
                let (x, y) = s.split_at(index);
                let x = x.parse::<i32>();
                if matches!(x, Err(_)) {
                    return Err(ParsePointError);
                }
                let y = y[1..].parse::<i32>();
                if matches!(y, Err(_)) {
                    return Err(ParsePointError);
                }
                Ok(Point {
                    _x: x.unwrap(),
                    _y: y.unwrap(),
                })
            }
        }
    }
}

fn study_char_bool_unit() {
    // Rust ä¸­çš„å­—ç¬¦ç±»å‹æ˜¯ `char`(æœ¬è´¨ä¸Šæ˜¯ä¸€ä¸ª `u32` ç±»å‹)ï¼Œå®ƒå ç”¨ 4 ä¸ªå­—èŠ‚ï¼Œå³ 32 ä½ã€‚
    // Rust çš„å­—ç¬¦ä¸ä»…ä»…æ˜¯ `ASCII`ï¼Œæ‰€æœ‰çš„ `Unicode` å€¼éƒ½å¯ä»¥ä½œä¸º Rust å­—ç¬¦ï¼Œ
    // åŒ…æ‹¬å•ä¸ªçš„ä¸­æ–‡ã€æ—¥æ–‡ã€éŸ©æ–‡ã€emoji è¡¨æƒ…ç¬¦å·ç­‰ç­‰
    println!("-----------------å­—ç¬¦-----------------");
    let a = 'a';
    let b: char = 'b';
    let c = 'ä¸­';
    let d = 'ğŸ¤£';
    println!("a = {}, b = {}, c = {}, d = {}", a, b, c, d);
    println!("å­—ç¬¦'ä¸­'çš„å­—èŠ‚é•¿åº¦ï¼š{}", c.len_utf8());
    println!("å­—ç¬¦'ğŸ¤£'çš„å­—èŠ‚é•¿åº¦ï¼š{}", d.len_utf8());
    println!("å­—ç¬¦'{}'å ç”¨äº†{}ä¸ªå­—èŠ‚å†…å­˜", d, std::mem::size_of_val(&c));

    // Rust ä¸­çš„å¸ƒå°”ç±»å‹æ˜¯ `bool`ï¼Œå®ƒå ç”¨ 1 ä¸ªå­—èŠ‚ã€‚
    // Rust ä¸­çš„å¸ƒå°”ç±»å‹åªæœ‰ä¸¤ä¸ªå€¼ï¼š`true` å’Œ `false`ã€‚
    println!("-----------------å¸ƒå°”-----------------");
    let a = true;
    let b: bool = false;
    println!("a = {}, b = {}", a, b);

    // Rust ä¸­çš„å•å…ƒç±»å‹æ˜¯ ()ï¼Œå®ƒå ç”¨ 0 ä¸ªå­—èŠ‚ï¼Œå”¯ä¸€çš„å€¼ä¹Ÿæ˜¯ ()ã€‚
    // main å‡½æ•°å°±è¿”å›è¿™ä¸ªå•å…ƒç±»å‹ ()ï¼Œä½ ä¸èƒ½è¯´ `main` å‡½æ•°æ— è¿”å›å€¼ï¼Œ
    // æ²¡æœ‰è¿”å›å€¼çš„å‡½æ•°åœ¨ Rust ä¸­æ˜¯æœ‰å•ç‹¬çš„å®šä¹‰çš„ï¼š`å‘æ•£å‡½æ•°( diverge function )`ï¼Œé¡¾åæ€ä¹‰ï¼Œæ— æ³•æ”¶æ•›çš„å‡½æ•°ã€‚
    // ä½ å¯ä»¥ç”¨ () ä½œä¸º map çš„å€¼ï¼Œè¡¨ç¤ºæˆ‘ä»¬ä¸å…³æ³¨å…·ä½“çš„å€¼ï¼Œåªå…³æ³¨ keyã€‚
    // è¿™ç§ç”¨æ³•å’Œ Go è¯­è¨€çš„ struct{} ç±»ä¼¼ï¼Œå¯ä»¥ä½œä¸ºä¸€ä¸ªå€¼ç”¨æ¥å ä½ï¼Œå¹¶ä¸”å®Œå…¨ä¸å ç”¨ä»»ä½•å†…å­˜ã€‚
    println!("-----------------å•å…ƒ-----------------");
    let a = ();
    let b: () = ();
    println!("a = {:?}, b = {:?}", a, b);
    println!("å•å…ƒç±»å‹()å ç”¨äº†{}ä¸ªå­—èŠ‚å†…å­˜", std::mem::size_of_val(&a));
}

fn study_rational_and_complex() {
    // Rust çš„æ ‡å‡†åº“ç›¸æ¯”å…¶å®ƒè¯­è¨€ï¼Œå‡†å…¥é—¨æ§›è¾ƒé«˜ï¼Œå› æ­¤æœ‰ç†æ•°å’Œå¤æ•°å¹¶æœªåŒ…å«åœ¨æ ‡å‡†åº“ä¸­
    // Rust æœ‰ä¸€ä¸ªå«åš `num` çš„ç¬¬ä¸‰æ–¹åº“ï¼Œå®ƒæä¾›äº†æœ‰ç†æ•°å’Œå¤æ•°çš„æ”¯æŒï¼Œå¯ä»¥é€šè¿‡ `cargo add num` å®‰è£…ã€‚
    println!("-----------------æœ‰ç†æ•°å’Œå¤æ•°-----------------");
    // re ä»£è¡¨å®éƒ¨ï¼Œim ä»£è¡¨è™šéƒ¨
    let a = num::complex::Complex { re: 2.1, im: -1.2 };
    let b = num::complex::Complex::new(11.1, 22.2);
    let result = a + b;

    println!("{} + {}i", result.re, result.im)
}

fn study_basic_data_types() {
    println!("-----------------æ•´å‹-----------------");
    // Rust ä¸­çš„æ•´å‹æœ‰ï¼šu8ã€i8ã€u16ã€i16ã€u32ã€i32ã€u64ã€i64ã€u128ã€i128ã€usizeã€isizeã€‚
    // `isize` å’Œ `usize` ç±»å‹å–å†³äºç¨‹åºè¿è¡Œçš„è®¡ç®—æœº CPU ç±»å‹ï¼š
    // isizeæ˜¯æŒ‡é’ˆå¤§å°çš„æœ‰ç¬¦å·æ•´æ•°ç±»å‹ï¼Œè€Œusizeæ˜¯æŒ‡é’ˆå¤§å°çš„æ— ç¬¦å·æ•´æ•°ç±»å‹ã€‚
    // è‹¥ CPU æ˜¯ 32 ä½çš„ï¼Œåˆ™è¿™ä¸¤ä¸ªç±»å‹æ˜¯ 32 ä½çš„ï¼ŒåŒç†ï¼Œè‹¥ CPU æ˜¯ 64 ä½ï¼Œé‚£ä¹ˆå®ƒä»¬åˆ™æ˜¯ 64 ä½ã€‚
    // Rust æ•´å‹é»˜è®¤ä½¿ç”¨ `i32`ï¼Œä¾‹å¦‚ `let i = 1`ï¼Œé‚£ `i` å°±æ˜¯ `i32` ç±»å‹ï¼Œ
    // å› æ­¤ä½ å¯ä»¥é¦–é€‰å®ƒï¼ŒåŒæ—¶è¯¥ç±»å‹ä¹Ÿå¾€å¾€æ˜¯æ€§èƒ½æœ€å¥½çš„ã€‚
    let a: i32 = 98_222;
    let b: i64 = 0xff;
    let c: isize = -0o77;
    let d: u32 = 0b1111_0000;
    // å­—èŠ‚èµ‹å€¼ï¼Œä»…é™äºu8
    let e: u8 = b'A';
    println!("a = {}, b = {}, c = {}, d = {}, e = {}", a, b, c, d, e);
    // æ•´å‹æº¢å‡º
    println!("-----------------æ•´å‹æº¢å‡º-----------------");
    // å½“åœ¨ debug æ¨¡å¼ç¼–è¯‘æ—¶ï¼ŒRust ä¼šåœ¨æ•´å‹æº¢å‡ºæ—¶ panicã€‚
    // å½“åœ¨ release æ¨¡å¼ç¼–è¯‘æ—¶ï¼ŒRustä¸æ£€æµ‹æº¢å‡ºã€‚ç›¸åï¼Œå½“æ£€æµ‹åˆ°æ•´å‹æº¢å‡ºæ—¶ï¼Œ
    // Rust ä¼šæŒ‰ç…§è¡¥ç å¾ªç¯æº¢å‡ºï¼ˆtwoâ€™s complement wrappingï¼‰çš„è§„åˆ™å¤„ç†ã€‚
    // å¦‚æœè¦æ˜¾å¼å¤„ç†å¯èƒ½çš„æº¢å‡ºï¼Œå¯ä»¥ä½¿ç”¨æ ‡å‡†åº“é’ˆå¯¹åŸå§‹æ•°å­—ç±»å‹æä¾›çš„è¿™äº›æ–¹æ³•ï¼š
    // ä½¿ç”¨ wrapping_* æ–¹æ³•åœ¨æ‰€æœ‰æ¨¡å¼ä¸‹éƒ½æŒ‰ç…§è¡¥ç å¾ªç¯æº¢å‡ºè§„åˆ™å¤„ç†ï¼Œä¾‹å¦‚ wrapping_add
    // ä½¿ç”¨ checked_* æ–¹æ³•æ—¶å‘ç”Ÿæº¢å‡ºï¼Œåˆ™è¿”å› None å€¼
    // ä½¿ç”¨ overflowing_* æ–¹æ³•è¿”å›è¯¥å€¼å’Œä¸€ä¸ªæŒ‡ç¤ºæ˜¯å¦å­˜åœ¨æº¢å‡ºçš„å¸ƒå°”å€¼
    // ä½¿ç”¨ saturating_* æ–¹æ³•ä½¿å€¼è¾¾åˆ°æœ€å°å€¼æˆ–æœ€å¤§å€¼
    let aa: u8 = 255;
    let bb: u8 = aa.wrapping_add(1);
    println!("aa = {}, bb = {}", aa, bb); //aa = 255, bb = 0
                                          // æµ®ç‚¹é™·é˜±
    println!("-----------------æµ®ç‚¹é™·é˜±-----------------");
    study_float_traps();
    //NaN
    println!("-----------------NaN-----------------");
    // å¯¹äºæ•°å­¦ä¸Šæœªå®šä¹‰çš„ç»“æœï¼Œä¾‹å¦‚å¯¹è´Ÿæ•°å–å¹³æ–¹æ ¹ `-42.1.sqrt()` ï¼Œä¼šäº§ç”Ÿä¸€ä¸ªç‰¹æ®Šçš„ç»“æœï¼š
    // Rust çš„æµ®ç‚¹æ•°ç±»å‹ä½¿ç”¨ `NaN` (not a number)æ¥å¤„ç†è¿™äº›æƒ…å†µã€‚
    // æ‰€æœ‰è·Ÿ `NaN` äº¤äº’çš„æ“ä½œï¼Œéƒ½ä¼šè¿”å›ä¸€ä¸ª `NaN`ï¼Œè€Œä¸” `NaN` ä¸èƒ½ç”¨æ¥æ¯”è¾ƒã€‚
    let x = (-42.0_f32).sqrt();
    if x.is_nan() {
        println!("æœªå®šä¹‰çš„æ•°å­¦è¡Œä¸º");
    }
    // æ— ç©·å¤§
    let inf = 1.0_f32 / 0.0_f32; // inf = Infinity
    println!("inf = {}", inf);

    //ç±»å‹æ¨æ–­
    println!("-----------------ç±»å‹æ¨æ–­-----------------");
    // é€šè¿‡ç±»å‹åç¼€çš„æ–¹å¼è¿›è¡Œç±»å‹æ ‡æ³¨ï¼š22æ˜¯i32ç±»å‹
    let twenty_two = 22i32;
    println!("twenty_two = {}", twenty_two);
    // å®šä¹‰ä¸€ä¸ªf32æ•°ç»„ï¼Œå…¶ä¸­42.0ä¼šè‡ªåŠ¨è¢«æ¨å¯¼ä¸ºf32ç±»å‹
    let forty_twos = [42.0, 42f32, 42.0_f32];
    // æ‰“å°æ•°ç»„ä¸­ç¬¬ä¸€ä¸ªå€¼ï¼Œå¹¶æ§åˆ¶å°æ•°ä½ä¸º2ä½
    println!("{:.2}", forty_twos[0]);

    // åºåˆ—
    println!("-----------------åºåˆ—-----------------");
    // Rust æä¾›äº†ä¸€ä¸ªéå¸¸ç®€æ´çš„æ–¹å¼ï¼Œç”¨æ¥ç”Ÿæˆè¿ç»­çš„æ•°å€¼ï¼Œä¾‹å¦‚ `1..5`ï¼Œç”Ÿæˆä» 1 åˆ° 4 çš„è¿ç»­æ•°å­—ï¼Œä¸åŒ…å« 5ã€‚
    for i in 1..5 {
        print!("{} ", i);
    }
    println!();
    // `1..=5`ï¼Œç”Ÿæˆä» 1 åˆ° 5 çš„è¿ç»­æ•°å­—ï¼ŒåŒ…å« 5ã€‚
    for i in 1..=5 {
        print!("{} ", i);
    }
    println!();

    // å°† `13.14` å–æ•´ï¼š`13.14_f32.round()`
    println!("-----------------å–æ•´-----------------");
    // round() æ–¹æ³•è¿”å›ä¸€ä¸ªæœ€æ¥è¿‘çš„æ•´æ•°ï¼Œå››èˆäº”å…¥
    println!("13.14_f32.round() = {}", 13.14_f32.round());
    // floor() æ–¹æ³•è¿”å›ä¸€ä¸ªæœ€æ¥è¿‘çš„æ•´æ•°ï¼Œå‘ä¸‹å–æ•´
    println!("13.99_f32.floor() = {}", 13.99_f32.floor());
}

fn study_float_traps() {
    // åº”å½“é¿å…åœ¨æµ®ç‚¹æ•°ä¸Šæµ‹è¯•ç›¸ç­‰æ€§ï¼Œå› ä¸ºäºŒè¿›åˆ¶ç²¾åº¦é—®é¢˜ï¼Œ
    // å¯¼è‡´äº† 0.1 + 0.2 å¹¶ä¸ä¸¥æ ¼ç­‰äº 0.3ï¼Œå®ƒä»¬å¯èƒ½åœ¨å°æ•°ç‚¹ N ä½åå­˜åœ¨è¯¯å·®ã€‚
    let abc: (f32, f32, f32) = (0.1, 0.2, 0.3);
    let xyz: (f64, f64, f64) = (0.1, 0.2, 0.3);

    // to_bits() è¿”å›äº†æµ®ç‚¹æ•°çš„äºŒè¿›åˆ¶è¡¨ç¤ºï¼Œå¹¶å°†å…¶è½¬æ¢ä¸ºæ•´æ•°ç±»å‹ã€‚
    // {:x} è¡¨ç¤ºä»¥åå…­è¿›åˆ¶çš„å½¢å¼è¾“å‡ºã€‚

    // å¯¹ f32 ç±»å‹åšåŠ æ³•æ—¶ï¼Œ0.1 + 0.2 çš„ç»“æœæ˜¯ 3e99999aï¼Œ0.3 ä¹Ÿæ˜¯ 3e99999aï¼Œ
    // å› æ­¤ f32 ä¸‹çš„ 0.1 + 0.2 == 0.3 é€šè¿‡æµ‹è¯•
    println!("abc (f32)");
    println!("   0.1 + 0.2: {:x}", (abc.0 + abc.1).to_bits());
    println!("         0.3: {:x}", (abc.2).to_bits());
    println!();

    // ä½†æ˜¯åˆ°äº† f64 ç±»å‹æ—¶ï¼Œç»“æœå°±ä¸ä¸€æ ·äº†ï¼Œå› ä¸º f64 ç²¾åº¦é«˜å¾ˆå¤šï¼Œå› æ­¤åœ¨å°æ•°ç‚¹éå¸¸åé¢å‘ç”Ÿäº†ä¸€ç‚¹å¾®å°çš„å˜åŒ–ï¼Œ
    // 0.1 + 0.2 ä»¥ 4 ç»“å°¾ï¼Œä½†æ˜¯ 0.3 ä»¥3ç»“å°¾ï¼Œè¿™ä¸ªç»†å¾®åŒºåˆ«å¯¼è‡´ f64 ä¸‹çš„æµ‹è¯•å¤±è´¥äº†
    println!("xyz (f64)");
    println!("   0.1 + 0.2: {:x}", (xyz.0 + xyz.1).to_bits());
    println!("         0.3: {:x}", (xyz.2).to_bits());
    println!();

    println!("abc.0 + abc.1 == abc.2: {}", abc.0 + abc.1 == abc.2);
    println!("xyz.0 + xyz.1 == xyz.2: {}", xyz.0 + xyz.1 == xyz.2);
}

fn study_variable_binding() {
    // Rustä¸­å˜é‡é»˜è®¤ä¸å¯å˜ï¼Œå¦‚æœéœ€è¦å¯å˜ï¼Œéœ€è¦ä½¿ç”¨ mut å…³é”®å­—ã€‚
    // mut è¡¨ç¤ºå¯å˜çš„ï¼Œä¹Ÿå°±æ˜¯è¯´ï¼Œæˆ‘ä»¬å¯ä»¥æ”¹å˜è¿™ä¸ªå˜é‡çš„å€¼ã€‚
    println!("-----------------å˜é‡ç»‘å®š-----------------");
    let mut x = 5;
    println!("The value of x is: {}", x);
    x = 6;
    println!("The value of x is: {}", x);

    // å¦‚æœä½ åˆ›å»ºäº†ä¸€ä¸ªå˜é‡å´ä¸åœ¨ä»»ä½•åœ°æ–¹ä½¿ç”¨å®ƒï¼ŒRust é€šå¸¸ä¼šç»™ä½ ä¸€ä¸ªè­¦å‘Šã€‚
    // ä½¿ç”¨ä¸‹åˆ’çº¿å¼€å¤´å¿½ç•¥æœªä½¿ç”¨çš„å˜é‡ã€‚
    let _y = 6;

    // let è¡¨è¾¾å¼ä¸ä»…ä»…ç”¨äºå˜é‡çš„ç»‘å®šï¼Œè¿˜èƒ½è¿›è¡Œå¤æ‚å˜é‡çš„è§£æ„ï¼Œ
    // å³ä»ä¸€ä¸ªç›¸å¯¹å¤æ‚çš„å˜é‡ä¸­ï¼ŒåŒ¹é…å‡ºè¯¥å˜é‡çš„ä¸€éƒ¨åˆ†å†…å®¹ã€‚
    println!("-----------------è§£æ„å¼ç»‘å®š-----------------");
    let (a, mut b): (bool, bool) = (true, false);
    // a = true,ä¸å¯å˜; b = falseï¼Œå¯å˜
    println!("a = {:?}, b = {:?}", a, b);
    b = true;
    // assert_eq! æ˜¯ä¸€ä¸ªå®ï¼Œå®ƒçš„ä½œç”¨æ˜¯æ¯”è¾ƒä¸¤ä¸ªå€¼æ˜¯å¦ç›¸ç­‰ï¼Œå¦‚æœä¸ç›¸ç­‰ï¼Œå°±ä¼š panicã€‚
    assert_eq!(a, b);

    // è§£æ„å¼èµ‹å€¼
    println!("-----------------è§£æ„å¼èµ‹å€¼-----------------");
    study_variable_binding_destructuring_assignment();

    // å˜é‡ä¸å¸¸é‡
    // å¸¸é‡ä½¿ç”¨ const å…³é”®å­—è€Œä¸æ˜¯ let å…³é”®å­—æ¥å£°æ˜ï¼Œå¹¶ä¸”å€¼çš„ç±»å‹å¿…é¡»æ ‡æ³¨ã€‚
    // å¸¸é‡ä¸å…è®¸ä½¿ç”¨ mut å…³é”®å­—ã€‚
    println!("-----------------å¸¸é‡-----------------");
    // Rust å¸¸é‡çš„å‘½åçº¦å®šæ˜¯å…¨éƒ¨å­—æ¯éƒ½ä½¿ç”¨å¤§å†™ï¼Œå¹¶ä½¿ç”¨ä¸‹åˆ’çº¿åˆ†éš”å•è¯
    const MAX_POINTS: u32 = 100_000;
    println!("MAX_POINTS = {}", MAX_POINTS);
    // å˜é‡é®è”½
    // Rust å…è®¸å£°æ˜ç›¸åŒçš„å˜é‡åï¼Œåœ¨åé¢å£°æ˜çš„å˜é‡ä¼šé®è”½æ‰å‰é¢å£°æ˜çš„å˜é‡ã€‚
    println!("-----------------å˜é‡é®è”½-----------------");
    study_variable_binding_shadowing();
}

struct Struct {
    e: i32,
}

fn study_variable_binding_destructuring_assignment() {
    let (a, b, c, d, e);

    (a, b) = (1, 2);
    // _ ä¸å…¶ä»–è¯­è¨€ä¸­çš„å ä½ç¬¦ç±»ä¼¼ï¼Œå®ƒè¡¨ç¤ºå¿½ç•¥è¿™ä¸ªå€¼ã€‚
    // .. çœç•¥å…¶ä½™çš„å€¼
    [c, .., d, _] = [1, 2, 3, 4, 5];
    Struct { e, .. } = Struct { e: 5 };

    assert_eq!([1, 2, 1, 4, 5], [a, b, c, d, e]);
    println!("[a, b, c, d, e] = {:?}", [a, b, c, d, e]);
}

fn study_variable_binding_shadowing() {
    let x = 5;
    // åœ¨å‡½æ•°çš„ä½œç”¨åŸŸå†…å¯¹ä¹‹å‰çš„xè¿›è¡Œé®è”½
    let x = x + 1;
    {
        // åœ¨å½“å‰çš„èŠ±æ‹¬å·ä½œç”¨åŸŸå†…ï¼Œå¯¹ä¹‹å‰çš„xè¿›è¡Œé®è”½
        let x = x * 2;
        // x = 12
        println!("The value of x in the inner scope is: {}", x);
    }

    // x = 6
    println!("The value of x is: {}", x);

    // å‡è®¾æœ‰ä¸€ä¸ªç¨‹åºè¦ç»Ÿè®¡ä¸€ä¸ªç©ºæ ¼å­—ç¬¦ä¸²çš„ç©ºæ ¼æ•°é‡
    let spaces = "   ";
    // è™½ç„¶ spaces.len()è¿”å›ä¸€ä¸ª usize ç±»å‹çš„å€¼ï¼Œä½†è¿™ç§ç»“æ„æ˜¯å…è®¸çš„.
    // ä»¥å˜é‡é®è”½å¯ä»¥å¸®æˆ‘ä»¬èŠ‚çœäº›è„‘ç»†èƒï¼Œä¸ç”¨å»æƒ³å¦‚ `spaces_str` å’Œ `spaces_num` æ­¤ç±»çš„å˜é‡åï¼›
    // ç›¸åæˆ‘ä»¬å¯ä»¥é‡å¤ä½¿ç”¨æ›´ç®€å•çš„ `spaces` å˜é‡åã€‚
    let spaces = spaces.len();
    println!("spaces = {}", spaces);
}
