use std::env;
use std::fs;
use std::path::Path;

// 一些项目希望编译第三方的非 Rust 代码，例如 C 依赖库；
// 一些希望链接本地或者基于源码构建的 C 依赖库；还有一些项目需要功能性的工具，
// 例如在构建之间执行一些代码生成的工作等。
// 对于这些目标，社区已经提供了一些工具来很好的解决，Cargo 并不想替代它们，
// 但是为了给用户带来一些便利，Cargo 提供了自定义构建脚本的方式，来帮助用户更好的解决类似的问题。

// 若要创建构建脚本，我们只需在项目的根目录下添加一个 build.rs 文件即可。
// 这样一来， Cargo 就会先编译和执行该构建脚本，然后再去构建整个项目。

// 关于构建脚本的一些使用场景如下：
// 构建 C 依赖库
// 在操作系统中寻找指定的 C 依赖库
// 根据某个说明描述文件生成一个 Rust 模块
// 执行一些平台相关的配置

// 构建脚本的生命周期
// 在项目被构建之前，Cargo 会将构建脚本编译成一个可执行文件，然后运行该文件并执行相应的任务。
// 在运行的过程中，脚本可以使用之前 println 的方式跟 Cargo 进行通信：
// 通信内容是以 cargo: 开头的格式化字符串。

// 需要注意的是，Cargo 也不是每次都会重新编译构建脚本，
// 只有当脚本的内容或依赖发生变化时才会。默认情况下，
// 任何文件变化都会触发重新编译，如果你希望对其进行定制，可以使用 rerun-if命令，后文会讲。

// 在构建脚本成功执行后，我们的项目就会开始进行编译。如果构建脚本的运行过程中发生错误，
// 脚本应该通过返回一个非 0 码来立刻退出，在这种情况下，构建脚本的输出会被打印到终端中。

fn main() {
    let out_dir = env::var_os("OUT_DIR").unwrap();
    let dest_path = Path::new(&out_dir).join("hello.rs");
    fs::write(
        &dest_path,
        "pub fn message() -> &'static str {
            \"Hello, World!\"
        }
        ",
    )
    .unwrap();
    println!("cargo:rerun-if-changed=build.rs");
}

// 以上代码中有几点值得注意：

// OUT_DIR 环境变量说明了构建脚本的输出目录，也就是最终生成的代码文件的存放地址
// 一般来说，构建脚本不应该修改 OUT_DIR 之外的任何文件
// 这里的代码很简单，但是我们这是为了演示，大家完全可以生成更复杂、更实用的代码
// return-if-changed 指令告诉 Cargo 只有在脚本内容发生变化时，才能重新编译和运行构建脚本。
// 如果没有这一行，项目的任何文件发生变化都会导致 Cargo 重新编译运行该构建脚本
